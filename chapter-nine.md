# Lists

* lists can be used as a collection or as an infinite series generated by a function
* can act as a stream datatype

## The list datatype

* `data [] a = [] | a : [a]`
* with no argument creates empty list
* `(:)` called cons, short for construct, takes value a and list of type a and creates [a]
* cons is a product because it takes two arguments, | is a sum type
* sum type can be though of like logical "or", product is like "and"

## Pattern matching on lists

* can use pattern matching on lists like any other datatype
* example using cons to return head of list
* `myHead (x : _) = x`
* or the tail: `myTail (_ : xs) = xs`
* these functions can't handle an empty list
* an empty list has type [a] but doesn't contain any values of type a
  
```
myTail :: [a] -> [a]
myTail [] = []
myTail (_ : xs) = xs
```

### Using Maybe

* Maybe makes failure case explicit, useful when programs get more complex
* instead of returning an empty list, can return nothing
* `data Maybe a = Nothing | Just a`
* myTail redone using Maybe:

```
safeTail :: [a] -> Maybe [a]
safeTail [] = Nothing
safeTail (x:[]) = Nothing
safeTail (_:xs) = Just xs
```

* still pattern matching on the list
* second case is for when list only has one value in it, so it doesn't return Just []

```
safeHead :: [a] -> Maybe [a]
safeHead [] = Nothing
safeHead (x:_) = Just x
```

## List's syntactic sugar

* (++) is the same as successive applications of `(:)`
* lists can be thought of as cons cells and spines, syntactic sugar obscures this
* `(1 : 2 : 3 : []) ++ 4 : []`
* cons cell are the second part of the data constructor, `a : [a]`
* is a conceptual space that values may inhabit
* spine is a connective structure that holds in the cons cells together and in place
* structure nests the cons cells rather than ordering them in a row
* different functions can treat the spine and cons cells different 

## Using ranges to construct lists

* several ways to construct lists, one way is with ranges
* uses two dots to separate the start and the end of the list
* `[1..10]` evaluates to `[1,2,3,4,5,6,7,8,9,10]`
* `[1,3..10]` evaluates to `[1,3,5,7,9]`
* `['t'..'z']` evaluates to `"tuvwxyz"`
* Enum functions underly the range syntax:
  
```
enumFrom :: Enum a => a -> [a]
enumFromThen :: Enum a => a -> a -> [a]

enumFromTo :: Enum a => a -> a -> [a]
enumFromThenTo :: Enum a => a -> a -> a -> [a]
```

* requires the type being ranged to have an instance of the Enum typeclass
* first two functions create lists of indefinite and maybe infinite length
* to be infinite msut be using a datatype with no upper bound like Integer
* enumFromTo must have its first argument be lower than the second

### Exercises: EnumFromTo

1. see file

## Extracting portions of lists

```
take :: Int -> [a] -> [a]
drop :: Int -> [a] -> [a]
splitAt :: Int -> [a] -> ([a], [a])
```

* `take 3 []` returns empty list []
* can use with list-building functions
* `take 10 (enumFrom 10)`
* drop is the opposite of take
* `drop 5 [1..10]` evaluates to `[6,7,8,9,10]`
* `drop 8 ['a'..'z']` evaluates to `"ijklmnopqrstuvwxyz"`
* entering an empty list returns an empty list
* splitAt takes a list and returns a tuple of two lists
* `splitAt 5 [1..10]` returns `([1,2,3,4,5],[6,7,8,9,10])`
* `splitAt 10 ['a'..'z']` `("abcdefghij","klmnopqrstuvwxyz")`
* `splitAt 5 []` returns `([],[])`

### cont.

* higher-order list functions
* `takeWhile :: (a -> Bool) -> [a] -> [a]`
* `dropWhile :: (a -> Bool) -> [a] -> [a]`
* takeWhile takes elements out of a list that meet a condition and stops when it meets an element that doesn't meet the condition
* `takeWhile (<3) [1..10]` returns `[1,2]`
* `takeWhile (<8) (enumFromTo 5 15)` `[5,6,7]`
* `takeWhile (>6) [1..10]` returns an empty list because the first element it meets is 1 which doesn't meet the condition
* dropWhile is obviously the opposite
* `dropWhile (<3) [1..10]` returns `[3,4,5,6,7,8,9,10]`
* `dropWhile (<8) (enumFromTo 5 15)` returns `[8,9,10,11,12,13,14,15]`
* `dropWhile (>6) [1..10]` returns `[1,2,3,4,5,6,7,8,9,10]`

### Exercises: Thy fearful symmetry

1. see file

## List comprehensions

* means of generating a new list from a list or lists
* come directly from the concept of set comprehensions in mathematics
* must have at least one list, called the generator that's the input for the comprehension
* may also have conditions to determine what elements are drawn or a function that operates on the elements
* `[ x^2 | x <- [1..10]]`
* x^2 is the output that applies to the members of the list
* pipe separates output function and input
* `x <- [1..10]` is the input set, a generator list and a variable that represents the elements being drawn from the list
* output is `[1,4,9,16,25,36,49,64,81,100]`

### Adding predicates

* comprehensions can optionally take predicates that limit the elements being drawn
* predicates must evaluate to Bool values
* items that meet True will be drawn from the list
* this will ignore the odds from the previous comprehension:
* `[x^2 | x <- [1..10], rem x 2 == 0]`
* evaluates to `[4,16,36,64,100]`

### Multiple generators

* comprehensions can also have multiple generators
* rightmost list will be exhausted first then the second rightmost etc
* `[x^y | x <- [1..5], y <- [2, 3]]` evaluates to `[1,1,4,8,9,27,16,64,25,125]`
* does 1^2 then 1^3 then 2^2 and so on
* can also add a predicate
* `[x^y | x <- [1..10], y <- [2, 3], x ^ y < 200]`
* evaluates to `[1,1,4,8,9,27,16,64,25,125,36,49,64,81,100]`
* can use comprehensions to generate a list of tuples
* `[(x, y) | x <- [1, 2, 3], y <- [6, 7]]`
* evaluates to `[(1,6),(1,7),(2,6),(2,7),(3,6),(3,7)]`
* can give list a name and use it for other comprehensions
* `mySqr = [x^2 | x <- [1..10]]`
* `[(x, y) | x <- mySqr, y <- [1..3], x < 4]`
* `[(1,1),(1,2),(1,3)]`

### Exercises: comprehend thy lists

1. `[4,16,36,64,100]`
2. `[(1, 64), (1, 81), (1, 100), (4, 64), (4, 81), (4, 100), (9, 64), (9, 81), (9, 100), (16, 64), (16, 81), (16, 100)]` and so on until x is 49
3. `[(1, 64), (1, 81), (1, 100), (4, 64), (4, 81)]`

### List comprehensions with strings

* `elem` tells you if an element is in a list or not
* `elem 'a' "Julie"` is False
* this takes all lower case letters out of a string
* `[x | x <- "Three Letter Acronym", elem x ['A'..'Z']]` evaluates to "TLA"
* can turn this into an acronym generator
* `acro xs = [x | x <- xs, elem x ['A'..'Z']]`
* uses xs for argument because it's a list, idiomatic to use a plural for a list argument

### Exercises: Square Cube

`mySqr = [x^2 | x <- [1..5]]`
`myCube = [y^3 | y <- [1..5]]`

1. `[(x, y) | x <- mySqr, y <- myCube]`
2. `[(x, y) | x <- mySqr, y <- myCube, x < 50, y < 50]`
3. `length [(x, y) | x <- mySqr, y <- myCube, x < 50, y < 50]`

## Spines and nonstrict evaluation

* lists are a recursive series of cons cells `a : [a]` terminated by the empty list
* spine is usually textually represented by the recursive cons operators
* `[1, 2, 3]` is equal to `1 : 2 : 3 : []` or `1 : (2 : (3 : []))`
* visualize as a tree structure where the parents are cons and the children are values

```
 : <------|
/ \ |
_  : <----| This is the "spine"
  / \ |
 _   : <--|
    / \
   _   []
```

* the cons cells contain the values not vice versa
* can evaluate cons cells independently of what they contain
* possible to evaluate only the spine of the list without evaluating individual values
* evaluation in this proceeds down the spine
* constructing the list proceeds up the spine
* lists aren't constructed until they are consumed, like everything in haskell
* until it's consumed, there's a series of placeholders as a blueprint of the list

### :sprint command

* can use sprint to print variables and see what has been evaluated already
* underscore represents expressions not yet evaluates
* GHC Haskell has optimization which introduce strictness to evaluate code faster when it doesn't change how the code evaluates
* can lead to quirky behaviour with sprint
* also best to use concrete types

```
let blah = enumFromTo 'a' 'z'
:sprint blah
blah = _
```

* blah is totally unevaluated

```
take 1 blah
"a"
:sprint blah
blah = 'a' : _
```

* one cons cell has been evaluated

```
take 1 blah
"ab"
:sprint blah
blah = 'a' : 'b' : _
```

* now two have been evaluated

```
length blah
26
:sprint blah
blah = "abcdefghijklmnopqrstuvwxyz"
```

#### Spines are evluated independently of values

* values are reduced to weak head normal form by default
* means that the expression is only evaluated as far as is necessary to reach a data constructor
* in WHNF expression could be fully evaluated and in normal form or could be evaluated to the point of reaching a data constructor or lambda awaiting an argument
* `(1, 2) -- WHNF & NF` is in normal form and WHNF
* `(1, 1 + 1)` is in WHNF but not NF
* `\x -> x * 10` is in both because it cannot be reduced any further yet
* `"Papu" ++ "chon"` is in neither because the outermost component of the expression is a function with both arguments that hasn't been evaluated
* `(1, "Papu" ++ "chon")` is in WHNF

```
let myNum :: [Int]; myNum = [1..10]
:sprint myNum
myNum = _
take 2 myNum
:sprint myNum
myNum = 1 : 2 : _
```

* this is WHNF evaluation. list has to be constructed by range but will only evaluate as far as it has to
* evaluating to normal form would mean recursing through entire list
* functions that are spine strict can force complete evaluation of spine 
* pattern matching is strict by default
* length is strict in the spine but not value, forces evaluation of spine without evaluating the values
* can write a function that forces spine and values:

```
mySum :: Num a => [a] -> a
mySum [] = 0
mySum (x : xs) = x + mySum xs
```

### Exercises: bottom madness

1. will return bottom
2. will return a value
3. will return bottom
4. will return a value
5. will return bottom
6-10. will return bottom

## Intermission: is it normal form?

1. NF
2. WHNF
3. neither
4. neither
5. neither
6. neither
7. WHNF

## Transforming lists of values

* Haskell tends to use higher-order functions for transforming data rather than manually recursing over and over
* common thing to do is return a list with a function applied to all its value
* map and fmap are used for this
* `map (+1) [1, 2, 3, 4]` `[2,3,4,5]`
* `map :: (a -> b) -> [a] -> [b]`

```
map :: (a -> b) -> [a] -> [b]
map _ [] = []
map f (x:xs) = f x : map f xs
```

* applies the function f to the head then uses cons on the next step
  
```
map (+1) [1, 2, 3]
map (+1) (1 : (2 : (3 : [])))
(+1) 1 : map (+1) (2 : (3 : []))
(+1) 1 : ((+1) 2 :(map (+1) (3 : [])))
(+1) 1 : ((+1) 2 : ((+1) 3 : (map (+1) [])))
(+1) 1 : ((+1) 2 : ((+1) 3 : []))

reducing it:
2 : ((+1) 2 : ((+1) 3 : []))
2 : 3 : (+1) 3 : []
2 : 3 : 4 : [] == [2, 3, 4]
```

* breaking it down without list syntactic sugar

```
       :
      / \
(+1) 1   :
        / \
  (+1) 2   :
          / \
    (+1) 3   []
```

* can use map with other lists types and functions
* `map fst [(2, 3), (4, 5), (6, 7), (8, 9)]` `[2,4,6,8]`
* `map (take 3) [[1..5], [1..5], [1..5]]`
* `[[1,2,3],[1,2,3],[1,2,3]]`
* `map (\x -> if x == 3 then (-x) else (x)) [1..10]`
* `[1,2,-3,4,5,6,7,8,9,10]`

### Exercises: more bottoms

1. will bottom
2. return value
3. bottom
4. will go through each value in list and see if it is a vowel
5. .
   1. [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
   2. [1, 10, 20]
   3. [15, 15, 15]

## Filtering list values

```
filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter pred (x:xs)
    | pred x = x : filter pred xs
    | otherwise = filter pred xs
```

* filter applies a function that outputs bool to a list and returns a new list of values that meet the condition
* `filter (\x -> (rem x 2) == 0) [1..20]`
* `[2,4,6,8,10,12,14,16,18,20]`
* `filter (\x -> elem x "aeiou") "abracadabra"`
* same as `[x | x <- "abracadabra", elem x "aeiou"]`

### Exercises: filtering

1. `filter (\x -> (rem x 3) == 0) [1..30]`
2. `f' = length . f`
3. `myFilter w = filter (\x -> (x /= "the" && x /= "a")) (words w)`

## Zipping lists

* combines values from multiple lists into a single list
* `zip [1, 2, 3] [4, 5, 6]` `[(1,4),(2,5),(3,6)]`
* stops when one list runs out of values
* returns empty list if one list is empty
* unzip does the opposite
* `unzip $ zip [1, 2, 3] [4, 5, 6]` `([1,2,3],[4,5,6])`
* zipWith applies function to both lists
* `zipWith (+) [1, 2, 3] [10, 11, 12]` `[11,13,15]`

### Zipping exercises

1. see file

## Chapter Exercises

### Data.Char

1. Char -> Bool and Char -> Char
2. see file

## Definitions

1. In type theory, a product type is a type made of a set of types
compounded over each other. In Haskell we represent products
using tuples or data constructors with more than one argument.
The “compounding” is from each type argument to the data
constructor representing a value that coexists with all the other
values simultaneously. Products of types represent a conjunction,
“and,” of those types. If you have a product of Bool and Int,
your terms will each contain a Bool and Int value.
2. In type theory, a sum type of two types is a type whose terms are
terms in either type, but not simultaneously. In Haskell sum
types are represented using the pipe, |, in a datatype definition.
Sums of types represent a disjunction, “or,” of those types. If
you have a sum of Bool and Int, your terms will be either a Bool
value or an Int value.
3. Cons is ordinarily used as a verb to signify that a list value has
been created by cons’ing a value onto the head of another list
value. In Haskell, (:) is the cons operator for the list type. It is
a data constructor defined in the list datatype:
```
1 : [2, 3]
-- [a] [b]
[1, 2, 3]
-- [c]
(:) :: a -> [a] -> [a]
-- [d] [e] [f]
```
a) The number 1, the value we are consing.
b) A list of the number 2 followed by the number 3.
c) The final result of consing 1 onto [2, 3].
d) The type variable 𝑎 corresponds to 1, the value we consed
onto the list value.
e) The first occurrence of the type [a] in the cons operator’s
type corresponds to the second and final argument (:) accepts,
which was [2, 3].
f) The second and final occurrence of the type [a] in the cons
operator’s type corresponds to the final result [1, 2, 3].
1. Cons cell is a data constructor and a product of the types a and
[a] as defined in the list datatype. Because it references the
list type constructor itself in the second argument, it allows for
nesting of multiple cons cells, possibly indefinitely with the use
of recursive functions, for representing an indefinite number
of values in series:
```
data [] a = [] | a : [a]
-- ^ cons operator
-- Defining it ourselves
data List a = Nil | Cons a (List a)
-- Creating a list using our list type
Cons 1 (Cons 2 (Cons 3 Nil))
```
Here (Cons 1 ...), (Cons 2 ...) and (Cons 3 Nil) are all individual
cons cells in the list [1, 2, 3].
5. The spine is a way to refer to the structure that glues a collection
of values together. In the list datatype it is formed by the recursive
nesting of cons cells. The spine is, in essence, the structure
of collection that isn’t the values contained therein. Often spine
will be used in reference to lists, but it applies with tree data
structures as well:
```
-- Given the list [1, 2, 3]
1 : --------| The nested cons operators
(2 : -----| here represent the spine.
(3 : --|
[]))
-- Blanking the irrelevant values out
_ : ----------|
(_ : -------|
(_ : ----> Spine
[]))
```